package dao;

import util.DBContext;
import model.Order;
import java.sql.*;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Data Access Object (DAO) for managing Order entities in the database. This
 * class provides methods to perform CRUD (Create, Read, Update) operations on
 * the 'Orders' table, utilizing the DBContext for database connections.
 */
public class OrderDAO {

    private DBContext dbContext;

    /**
     * Constructor for OrderDAO. Initializes the DBContext instance.
     */
    public OrderDAO() {
        this.dbContext = new DBContext();
    }

    /**
     * Retrieves all orders associated with a specific user. Orders are sorted
     * by order date in descending order (newest first).
     *
     * @param userId The ID of the user whose orders are to be retrieved.
     * @return An ArrayList containing Order objects, or an empty ArrayList if
     * no orders are found.
     */
    public ArrayList<Order> getOrdersByUser(int userId) {
        ArrayList<Order> orders = new ArrayList<>();
        String sql = "SELECT orderId, userId, totalPrice, status, orderDate, shippingAddress FROM Orders WHERE userId = ? ORDER BY orderDate DESC";

        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, userId);
            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                int orderId = rs.getInt("orderId");
                int fetchedUserId = rs.getInt("userId");
                double totalPrice = rs.getDouble("totalPrice");
                String status = rs.getString("status");
                Timestamp orderDate = rs.getTimestamp("orderDate");
                String shippingAddress = rs.getString("shippingAddress");

                Order order = new Order(orderId, fetchedUserId, totalPrice, status, orderDate, shippingAddress);
                orders.add(order);
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error retrieving orders for user " + userId, e);
        }
        return orders;
    }

    /**
     * Retrieves a single order by its unique ID.
     *
     * @param orderId The ID of the order to retrieve.
     * @return An Order object if found, or null if no order matches the given
     * ID.
     */
    public Order getOrderById(int orderId) {
        Order order = null;
        String sql = "SELECT orderId, userId, totalPrice, status, orderDate, shippingAddress FROM Orders WHERE orderId = ?";

        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, orderId);
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) { // Only one result expected for a unique orderId
                int fetchedUserId = rs.getInt("userId");
                double totalPrice = rs.getDouble("totalPrice");
                String status = rs.getString("status");
                Timestamp orderDate = rs.getTimestamp("orderDate");
                String shippingAddress = rs.getString("shippingAddress");

                order = new Order(orderId, fetchedUserId, totalPrice, status, orderDate, shippingAddress);
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error retrieving order by ID " + orderId, e);
        }
        return order;
    }

    /**
     * Creates a new order record in the database. The orderId and orderDate are
     * automatically generated by the database. If successful, the orderId of
     * the passed Order object will be updated with the newly generated ID.
     *
     * @param order The Order object containing the user ID, total price, and
     * shipping address.
     * @return true if the order was created successfully, false otherwise.
     */
    public boolean createOrder(Order order) {
        String sql = "INSERT INTO Orders (userId, totalPrice, status, shippingAddress) VALUES (?, ?, ?, ?)";
        boolean success = false;
        ResultSet rs = null;

        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            pstmt.setInt(1, order.getUserId());
            pstmt.setDouble(2, order.getTotalPrice());
            pstmt.setString(3, order.getStatus());
            pstmt.setString(4, order.getShippingAddress());

            int affectedRows = pstmt.executeUpdate();

            if (affectedRows > 0) {
                rs = pstmt.getGeneratedKeys();
                if (rs.next()) {
                    order.setOrderId(rs.getInt(1)); // Update the orderId of the Order object
                    success = true;
                }
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error creating new order", e);
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException e) {
                    Logger.getLogger(OrderDAO.class.getName()).log(Level.WARNING, "Error closing ResultSet", e);
                }
            }
        }
        return success;
    }

    /**
     * Updates the status of an existing order.
     *
     * @param orderId The ID of the order to update.
     * @param status The new status for the order (e.g., 'Processing',
     * 'Shipped', 'Completed', 'Cancelled').
     * @return true if the order status was updated successfully, false
     * otherwise (e.g., order not found).
     */
    public boolean updateOrderStatus(int orderId, String status) {
        String sql = "UPDATE Orders SET status = ? WHERE orderId = ?";

        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, status);
            pstmt.setInt(2, orderId);

            int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;

        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error updating order status for order ID " + orderId, e);
            return false;
        }
    }

    public ArrayList<Order> getCompletedOrders() {
        ArrayList<Order> orders = new ArrayList<>();
        String sql = "SELECT orderId, userId, totalPrice, status, orderDate, shippingAddress FROM Orders WHERE status = 'Completed' ORDER BY orderDate DESC";

        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                int orderId = rs.getInt("orderId");
                int userId = rs.getInt("userId");
                double totalPrice = rs.getDouble("totalPrice");
                String status = rs.getString("status");
                Timestamp orderDate = rs.getTimestamp("orderDate");
                String shippingAddress = rs.getString("shippingAddress");

                orders.add(new Order(orderId, userId, totalPrice, status, orderDate, shippingAddress));
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error retrieving completed orders", e);
        }

        return orders;
    }

    public ArrayList<Order> getProcessingOrders() {
        ArrayList<Order> orders = new ArrayList<>();
        String sql = "SELECT orderId, userId, totalPrice, status, orderDate, shippingAddress FROM Orders WHERE ( status = 'Pending' OR status = 'Processing' OR status = 'Shipped') ORDER BY orderDate DESC";

        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                int orderId = rs.getInt("orderId");
                int userId = rs.getInt("userId");
                double totalPrice = rs.getDouble("totalPrice");
                String status = rs.getString("status");
                Timestamp orderDate = rs.getTimestamp("orderDate");
                String shippingAddress = rs.getString("shippingAddress");

                orders.add(new Order(orderId, userId, totalPrice, status, orderDate, shippingAddress));
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error retrieving non-completed orders", e);
        }

        return orders;
    }

    public ArrayList<Order> getCompletedOrdersByUser(int userId) {
        ArrayList<Order> orders = new ArrayList<>();
        String sql = "SELECT orderId, userId, totalPrice, status, orderDate, shippingAddress "
                + "FROM Orders WHERE userId = ? AND status = 'Completed' ORDER BY orderDate DESC";

        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, userId);
            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                int orderId = rs.getInt("orderId");
                double totalPrice = rs.getDouble("totalPrice");
                String status = rs.getString("status");
                Timestamp orderDate = rs.getTimestamp("orderDate");
                String shippingAddress = rs.getString("shippingAddress");

                orders.add(new Order(orderId, userId, totalPrice, status, orderDate, shippingAddress));
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error retrieving completed orders for user " + userId, e);
        }

        return orders;
    }

    public ArrayList<Order> getCancelledOrdersByUser(int userId) {
        ArrayList<Order> orders = new ArrayList<>();
        String sql = "SELECT orderId, userId, totalPrice, status, orderDate, shippingAddress "
                + "FROM Orders WHERE userId = ? AND status = 'Cancelled' ORDER BY orderDate DESC";

        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, userId);
            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                int orderId = rs.getInt("orderId");
                double totalPrice = rs.getDouble("totalPrice");
                String status = rs.getString("status");
                Timestamp orderDate = rs.getTimestamp("orderDate");
                String shippingAddress = rs.getString("shippingAddress");

                orders.add(new Order(orderId, userId, totalPrice, status, orderDate, shippingAddress));
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error retrieving completed orders for user " + userId, e);
        }

        return orders;
    }

    public ArrayList<Order> getProcessingOrdersByUser(int userId) {
        ArrayList<Order> orders = new ArrayList<>();
        String sql = "SELECT orderId, userId, totalPrice, status, orderDate, shippingAddress "
                + "FROM Orders WHERE userId = ? AND ( status = 'Pending' OR status = 'Processing' OR status = 'Shipped') ORDER BY orderDate DESC";

        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, userId);
            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                int orderId = rs.getInt("orderId");
                double totalPrice = rs.getDouble("totalPrice");
                String status = rs.getString("status");
                Timestamp orderDate = rs.getTimestamp("orderDate");
                String shippingAddress = rs.getString("shippingAddress");

                orders.add(new Order(orderId, userId, totalPrice, status, orderDate, shippingAddress));
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error retrieving non-completed orders for user " + userId, e);
        }

        return orders;
    }

    public int insertOrder(Order order) {
        String sql = "INSERT INTO Orders (userId, totalPrice, status, shippingAddress, orderDate) VALUES (?, ?, ?, ?, ?)";
        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            pstmt.setInt(1, order.getUserId());
            pstmt.setDouble(2, order.getTotalPrice());
            pstmt.setString(3, order.getStatus());
            pstmt.setString(4, order.getShippingAddress());
            pstmt.setTimestamp(5, order.getOrderDate());

            int rows = pstmt.executeUpdate();
            if (rows > 0) {
                ResultSet rs = pstmt.getGeneratedKeys();
                if (rs.next()) {
                    return rs.getInt(1);
                }
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error inserting order", e);
        }
        return -1;
    }

    public ArrayList<Order> getProcessingOrdersBySeller(int sellerId) {
        ArrayList<Order> orders = new ArrayList<>();
        String sql = "SELECT DISTINCT o.orderId, o.userId, o.totalPrice, o.status, o.orderDate, o.shippingAddress "
                + "FROM Orders o "
                + "JOIN OrderItems oi ON o.orderId = oi.orderId "
                + "JOIN Products p ON oi.productId = p.productId "
                + "WHERE p.sellerId = ? AND o.status IN ('Pending', 'Processing', 'Shipped') "
                + "ORDER BY o.orderDate DESC";
        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, sellerId);
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                orders.add(new Order(
                        rs.getInt("orderId"),
                        rs.getInt("userId"),
                        rs.getDouble("totalPrice"),
                        rs.getString("status"),
                        rs.getTimestamp("orderDate"),
                        rs.getString("shippingAddress")
                ));
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error getting processing orders for seller " + sellerId, e);
        }
        return orders;
    }

    public ArrayList<Order> getCompletedOrdersBySeller(int sellerId) {
        ArrayList<Order> orders = new ArrayList<>();
        String sql = "SELECT DISTINCT o.orderId, o.userId, o.totalPrice, o.status, o.orderDate, o.shippingAddress "
                + "FROM Orders o "
                + "JOIN OrderItems oi ON o.orderId = oi.orderId "
                + "JOIN Products p ON oi.productId = p.productId "
                + "WHERE p.sellerId = ? AND o.status = 'Completed' "
                + "ORDER BY o.orderDate DESC";
        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, sellerId);
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                orders.add(new Order(
                        rs.getInt("orderId"),
                        rs.getInt("userId"),
                        rs.getDouble("totalPrice"),
                        rs.getString("status"),
                        rs.getTimestamp("orderDate"),
                        rs.getString("shippingAddress")
                ));
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error getting completed orders for seller " + sellerId, e);
        }
        return orders;
    }

    public ArrayList<Order> getCancelledOrdersBySeller(int sellerId) {
        ArrayList<Order> orders = new ArrayList<>();
        String sql = "SELECT DISTINCT o.orderId, o.userId, o.totalPrice, o.status, o.orderDate, o.shippingAddress "
                + "FROM Orders o "
                + "JOIN OrderItems oi ON o.orderId = oi.orderId "
                + "JOIN Products p ON oi.productId = p.productId "
                + "WHERE p.sellerId = ? AND o.status = 'Cancelled' "
                + "ORDER BY o.orderDate DESC";
        try (Connection conn = dbContext.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, sellerId);
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                orders.add(new Order(
                        rs.getInt("orderId"),
                        rs.getInt("userId"),
                        rs.getDouble("totalPrice"),
                        rs.getString("status"),
                        rs.getTimestamp("orderDate"),
                        rs.getString("shippingAddress")
                ));
            }
        } catch (SQLException e) {
            Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, "Error getting cancelled orders for seller " + sellerId, e);
        }
        return orders;
    }

}
